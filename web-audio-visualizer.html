
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="utf-8" />
	<title>Web Audio Visualizer</title>
    <link href="https://fonts.googleapis.com/css?family=Quicksand:400,700" rel="stylesheet">
	<style>
	   body {
           background: #191919;
           font-family: Quicksand, verdana, sans serif;
           color:aliceblue;
           margin-top:0px;
           width:100%;
           height:100%;
        }

      canvas {
          float:right;
          margin-left:10px;
          margin-top:0px;
          box-shadow: 4px 4px 8px rgba(0,0,0,0.5);
          background: black;
      }
      
      #controls{
      	  margin-left:10px;
        
      }
      #title{
         font-size:50px;
         margin-left:10px;
         margin-bottom:-40px;
           
      }
      hr{
         margin-bottom:50px;
      }
      
	</style>
	<script>
    // make stars
    // make skeleton heads
    // program heads
	// An IIFE ("Iffy") - see the notes in mycourses
	(function(){
		"use strict";
		
		var NUM_SAMPLES = 256;
		var SOUND_1 = 'media/PaperPlanes.mp3';
		var SOUND_2 = 'media/SpookyScarySkeletons.mp3';
		var SOUND_3 = 'media/HighScore.mp3';
		var currentSound = SOUND_1;
        var audioElement;
		var analyserNode;
        
        //Stars Variables
		var starCount=200;
		var starsx = [];
        var starsy = [];
        
        var delayAmount=0;
        var delayNode;
        
		    var canvas,ctx;
       
        var delay=false, glitch=false;
        
        var alph= 0.3;
        
        var colors = new Array('rgb(0,140,175)', 'rgb(0,230,255)', 'rgb(255,255,255)');
        var barx,bartop,barbot;
        var gravCircs = [];
        var amtCircs = 20;
        var prevData = [NUM_SAMPLES];
        
		var skullHead, skullJaw, skullHelmet;

		function init(){
			// set up canvas stuff
			canvas = document.querySelector('canvas');
			ctx = canvas.getContext("2d");
      ctx.canvas.width = window.innerWidth-400;
      ctx.canvas.height = window.innerHeight-100;
       document.querySelector("#delay").onchange=function(e){
           
            if(this.checked){
                delayAmount=0.5;
                console.log('checked');
            }
            else{
                delayAmount=0;
            }
        };   
        document.querySelector("#glitch").onchange=function(e){
            if(this.checked){
                glitch=true;
                console.log('weirdly checked');
            }
            else{
                glitch=false;
                console.log('not weirdly checked');
            }
        };       
      initializeStars();
          // get reference to <audio> element on page
			audioElement = document.querySelector('audio');
			
			// call our helper function and get an analyser node
			analyserNode = createWebAudioContextWithAnalyserNode(audioElement);
			
			// get sound track <select> and Full Screen button working
			setupUI();

			// Get the Skull images
            skullHelmet= new Image();
            skullHelmet.src="media/skulls-Helmet.png";
            
            skullHead = new Image();
            skullHead.src="media/skulls-Top.png"
            
            skullJaw=new Image();
            skullJaw.src="media/skulls-Bottom.png";
			
			// load and play default sound into audio element
			playStream(audioElement,SOUND_1);
			// start animation loop
			update();
		}
		
		function initializeStars(){ //Initialize the stars
        
            for(var i=0; i<starCount; i++){

                var xPos=Math.random()*canvas.width;
                var yPos = Math.random()*canvas.height;

               starsx[i]=xPos;
               starsy[i]=yPos;
            }
        }

        function createGravity(x, y, rad){    //creates a gravity circle and adds to array
            var circ = {
                gxPos : x,
                gyPos : y,
                gxSpeed : Math.random() * 3 - .5,
                gySpeed : Math.random() * 3,
                gRadius : rad,
                grSpeed : Math.random() * 2,
                gColor: colors[Math.floor(Math.random()*3)]
            }
            gravCircs.push(circ);
        }

        function zeroGravity(){   //updating and drawing all existing gravity circles
            for(var i = 0; i < gravCircs.length; i++){
                gravCircs[i].gxPos += gravCircs[i].gxSpeed;   //update positions and radius shrinks
                gravCircs[i].gyPos -= gravCircs[i].gySpeed;
                gravCircs[i].gRadius -= gravCircs[i].grSpeed;

                if(gravCircs[i].gRadius < 0){   //circles that cannot be seen are removed from array
                    gravCircs.splice(i, 1);
                }
                else{     //draw gravity circles
                  ctx.save();
                  ctx.fillStyle = gravCircs[i].gColor;
                  ctx.beginPath();
                  ctx.arc(gravCircs[i].gxPos, gravCircs[i].gyPos, gravCircs[i].gRadius, 0, Math.PI*2, false);
                  ctx.fill();
                  ctx.closePath();
                  ctx.restore();
                }
            }
        }

        function drawStar(xPos, yPos,alpha){
            alpha=(alpha/100)-1;

            ctx.beginPath();
            ctx.fillStyle='rgba(255,255,255,'+alpha+')';
            ctx.arc(xPos,yPos,2, 0,2*Math.PI,false);
            ctx.fill();

        }
		function createWebAudioContextWithAnalyserNode(audioElement) {
			var audioCtx, analyserNode, sourceNode;

			// create new AudioContext
			audioCtx = new (window.AudioContext || window.webkitAudioContext);
            
		
            delayNode=audioCtx.createDelay();
            
            // create an analyser node
			analyserNode = audioCtx.createAnalyser();
			
			// fft stands for Fast Fourier Transform
			analyserNode.fftSize = NUM_SAMPLES;
			
			// this is where we hook up the <audio> element to the analyserNode
			sourceNode = audioCtx.createMediaElementSource(audioElement); 
			sourceNode.connect(audioCtx.destination);
            
            sourceNode.connect(delayNode);
            delayNode.connect(analyserNode);
            analyserNode.connect(audioCtx.destination);
			
			// here we connect to the destination i.e. speakers
			analyserNode.connect(audioCtx.destination);
			return analyserNode;
		}
		
		function setupUI(){
   
			document.querySelector("#trackSelect").onchange = function(e){
				playStream(audioElement,e.target.value);
				currentSound = e.target.value;
			};
			
      document.querySelector("#colorSelect").onchange = function(e){
        switch(e.target.value){
          case 'blue':
            colors = new Array('rgb(0,140,175)', 'rgb(0,230,255)', 'rgb(255,255,255)');
            break;
          case 'orange':
            colors = new Array('rgb(255,80,0)', 'rgb(255,175,110)', 'rgb(255,255,255)');
            break;
          case 'red':
            colors = new Array('rgb(255,0,59)', 'rgb(255,130,125)', 'rgb(255,255,255)');
            break;
          case 'pink':
            colors = new Array('rgb(255,0,125)', 'rgb(255,135,230)', 'rgb(255,255,255)');
            break;
          case 'purple':
            colors = new Array('rgb(160,0,220)', 'rgb(210,125,255)', 'rgb(255,255,255)');
            break;
          case 'green':
            colors = new Array('rgb(0,185,120)', 'rgb(0,245,165)', 'rgb(255,255,255)');
            break;
          case 'allColors':
            colors = new Array('rgb(0,140,175)', 'rgb(0,230,255)', 'rgb(255,255,255)');
            break;
        }
      };
      
			document.querySelector("#fsButton").onclick = function(){
				requestFullscreen(canvas);
			};
      
      document.querySelector("#bubbles").onchange = function(e){
          amtCircs = e.target.value;
          console.log(amtCircs);
      };
document.querySelector("#opac").onchange = function(e){
          alph = e.target.value;
          console.log(amtCircs);
      };
      document.querySelector("#glitch").onchange = function(e){
          glitch = e.target.checked;
      };
		}
		
		function playStream(audioElement,path){
			audioElement.src = path;
			audioElement.play();
			audioElement.volume = 0.5;
			
		}
		
		function update() { 
			// this schedules a call to the update() method in 1/60 seconds
			requestAnimationFrame(update);
			
			// create a new array of 8-bit integers (0-255)
			var data = new Uint8Array(NUM_SAMPLES/2); 
			
			// populate the array with the frequency data
			// notice these arrays can be passed "by reference" 
			analyserNode.getByteFrequencyData(data);
		
            var jawY = 160;
			
			// DRAW!
			ctx.clearRect(0,0, 2000,1250); 
			//make stars
            for(var i=0; i<starCount; i++){
                 drawStar(starsx[i], starsy[i], data[5]);
              }
            
            var barSpacing = 5;
			var barWidth = (canvas.width - barSpacing*29)/30;
			var barHeight = 100;
			var topSpacing = 50;
           
			if(currentSound==SOUND_2){
                //draw first skull
                 var skullWidth = 270+(data[0]*0.2);
                 var skullHeight = 290+(data[0]*0.2);
                 var skullY = data[1];
                 if (skullY<180){
                    skullY=180;
                }
            else if(skullY>160){
                    skullY=data[1]-50;
                }
                
                ctx.save();
                ctx.translate(-(data[0]*0.1),-(data[0]*0.1));
                ctx.drawImage(skullJaw, (canvas.width/5.5)-5, skullY+100,skullWidth,skullHeight);
                ctx.drawImage(skullHead, canvas.width/5.5, 170,skullWidth,skullHeight);
                
                ctx.drawImage(skullHelmet, canvas.width/5.5,170,skullWidth,skullHeight);
                
                //draw second skull
                ctx.drawImage(skullJaw, (canvas.width/1.5)-5, skullY+100,skullWidth,skullHeight);
                ctx.drawImage(skullHead, canvas.width/1.5, 170,skullWidth,skullHeight);
                
                ctx.drawImage(skullHelmet, canvas.width/1.5,170,skullWidth,skullHeight);
                ctx.restore();
            }
//draw the gradient
            ctx.save();
            ctx.globalAlpha=alph;
            ctx.filter="blur(10px)";
            var grd = ctx.createLinearGradient(0,1000,0,0);
            
            grd.addColorStop(0,"rgba(255,0,59,1)");
            grd.addColorStop(1,"rgba(0,230,255,0.6)");
            ctx.fillStyle=grd;
            ctx.fillRect(0, canvas.height/2, canvas.width, canvas.height);
			 ctx.restore();
			// loop through the data and draw!
			ctx.lineCap = 'round';

			for(var i=0; i<85; i++) { 
          
				// the higher the amplitude of the sample (bin) the taller the bar
				// remember we have to draw our bars left-to-right and top-down

          barx = i * (barWidth + barSpacing) + barWidth/2;
          bartop = topSpacing + 256-data[i]+100;
          barbot = bartop + barHeight+100;

          if(currentSound == SOUND_2){
            if((i < 5 || i > 11) && (i < 19 || i > 25)){
              drawBar(colors[0], barx, bartop, barbot, barWidth);
              drawBar(colors[1], barx, barbot - bartop*barHeight/310, barbot, barWidth-5);
              drawBar(colors[2], barx, barbot - bartop*barHeight/450, barbot, barWidth-11);

              if((data[i] - prevData[i]) >= amtCircs){
                  createGravity(i * (barWidth + barSpacing) + barWidth/2, topSpacing + 256-data[i], barWidth);
              }
            }
          }
          
          else{
            drawBar(colors[0], barx, bartop, barbot, barWidth);
            drawBar(colors[1], barx, barbot - bartop*barHeight/310, barbot, barWidth-5);
            drawBar(colors[2], barx, barbot - bartop*barHeight/450, barbot, barWidth-11);

            if((data[i] - prevData[i]) >= amtCircs){
                createGravity(i * (barWidth + barSpacing) + barWidth/2, topSpacing + 256-data[i], barWidth);
            }
          }
          prevData[i] = data[i];
      }
          zeroGravity();
          manipulatePixels();
          manipulateAudio();
            
          
		} //End of update
        
		// HELPER
		function makeColor(red, green, blue, alpha){
   			var color='rgba('+red+','+green+','+blue+', '+alpha+')';
   			return color;
		}

    function drawBar(color, x, top, bot, width){
        ctx.strokeStyle = color; 
        ctx.lineWidth = width;
        ctx.beginPath();
        ctx.moveTo(x, top);
        ctx.lineTo(x, bot);
        ctx.stroke();
    }
		
		 // FULL SCREEN MODE
		function requestFullscreen(element) {
			if (element.requestFullscreen) {
			  element.requestFullscreen();
			} else if (element.mozRequestFullscreen) {
			  element.mozRequestFullscreen();
			} else if (element.mozRequestFullScreen) { // camel-cased 'S' was changed to 's' in spec
			  element.mozRequestFullScreen();
			} else if (element.webkitRequestFullscreen) {
			  element.webkitRequestFullscreen();
			}
			// .. and do nothing if the method is not supported
		};
        
        function manipulateAudio(){
            delayNode.delayTime.value=delayAmount;
        }
		
    function manipulatePixels(){
      var imageData=ctx.getImageData(0,0,canvas.width, canvas.height);
      
      var data = imageData.data;
      var length = data.length;
      var width= imageData.width;
      
      for(var i=0; i<length; i+=4){
          if(glitch){
            var row = Math.floor(i/4/width);
            if (row%200>=0 && row%200<=150){
              data[i]= data[i+24];
              data[i+1]= data[i+25];
              data[i+2]= data[i+26];
              data[i+3]= data[i+27];
            }
            else if(row%175>=0 && row%175<=20){
              data[i]= data[i-24];
              data[i+1]= data[i-23];
              data[i+2]= data[i-22];
              data[i+3]= data[i-21];
            }
          }
      }
      ctx.putImageData(imageData,0,0);
    }
		
		window.addEventListener("load",init);
	}());
		
	</script>
</head>
<body>
	<canvas id="canvas"></canvas>
    <div id="title"> 
        <p> SPACE VIS</p>
       
    </div>
     <hr>
	<div id="controls">
		<audio controls loop></audio><br/>
        <br/>
		<label>Choose Track: 
			<select id="trackSelect">
				<option value="media/PaperPlanes.mp3" selected>Paper Planes</option>
				<option value="media/SpookyScarySkeletons.mp3">Spooky Scary Skeletons</option>
				<option value="media/HighScore.mp3">High Score</option>
			</select>
		</label><br>
    <label>Color Scheme: 
      <select id="colorSelect" >
        <option value="blue">Blue</option>
        <option value="orange">Orange</option>
        <option value="red">Red</option>
        <option value="pink">Pink</option>
        <option value="purple">Purple</option>
        <option value="green">Green</option>
        <option value="allColors">All the Colors</option>
      </select>
    </label>
		<br/>
        <br/>
        <label for="bubbles"> Bubbles Slider</label> <br/>
        <input id="bubbles" type="range" min="10" max="60" step="3" value="20">
        <span id="sliderResults">???</span> <br>
        
        <label for="opac"> Gradient Opacity Slider</label> <br/>
        <input id="opac" type="range" min="0" max="1" step="0.05" value="0.3">
        <br/>
        
        <input type="checkbox" id="glitch" name="glitch" value="false"> Glitch <br>
        <input type="checkbox" id="delay" name="delay" value="false"> Delay <br>
		<br/>
        <button id="fsButton">Go Full Screen</button><br>
	</div>
</body>
</html>
